# -*- coding: utf-8 -*-
"""
Exercise 5 - Creating a continuous-time Markov chain class


@author: aarcanjo
instructions by: jembrown

The point of this exercise is to define a new class, called ctmc (for
continuous-time Markov chain), that contains all necessary information and
methods related to such a chain, running simulations of these chains,
calculating summaries of chains, calculating probabilities of specific
character histories, calculating marginal probabilities of starting and ending
states, and estimating branch lengths from the marginal probabilities using
maximum likelihood.
This exercise is roughly divided into three steps:
(a) Define the ctmc class and its __init__ method. In the __init__, set up the
following variables associated with instances of ctmc:
- time (or branch length)
- state space (for our purposes this will usually be the 4 nucleotides)
- stationary (or equilibrium) frequencies of the states
- an 'R' vector defining the relative propensity for diff't changes
- a 'Q' matrix used to define rates of changes and calc. probabilities
- the number of simulations (or independent chains or sites)
- lists of event times generated by the simulations
- lists of event states generated by the simulations
- a list of starting states across simulations (optional - could also be the
  first element of the event states lists)
- a list of character history probabilities
- a list of marginal probabilities (using just starting and ending states,
  along with the branch length)

NOTES: In the usual method for defining GTR-class Q-matrices in phylogenetics,
the equilibrium frequencies and R-vector rates are used to define elements of
the Q-matrix. You can initialize them in any way you like, but it would be a
good idea to write a function to make sure they are all consistent and to
update elements of the Q-matrix when equil. frequencies or R-rates change.

(b) Define a method for simulating character histories using the Q-matrix.
(c) Define a method that estimates branch lengths from marginal probabilities
using maximum likelihood. Use a 'site-independent' model, where the marginal
probability across the entire data set (i.e., across all simulations jointly)
is simply the product of the site probabilities.
"""

# Import statements


class Ctmc(object):
    """
    A class defining a continuous-time Markov chain (CTMC)
    """

    def __init__(self, Q=None, v=0.0, st_space=['A', 'C', 'T', 'G'],
                 steady_freqs=[.25, .25, .25, .25],
                 R_vector=[.5, .5, .5, .5, .5, .5], numSim=1):
        self.Q = self.grtQ(steady_freqs, R_vector)  # Q matrix
        self.v = v  # branch length
        self.st_space = st_space  # states space
        self.steady_freqs = steady_freqs  # stationary frequencies
        self.R_vector = R_vector  # relative propensities of nucl. change
        self.numSim = numSim  # the number of simulations
        self.waiting_time = []  # empty list to store the waiting times
        self.events_lists = []  # empty list to store the simulations
        self.start_state = []  # empty list to store starting states
        self.end_state = []  # empty list to store ending states
        self.hits_probs = []  # empty list to store char. history probabilities
        self.marg_probs = []  # empty list to store marginal probabilities
        # self.simulate()  # simulate the Markov Chain when creating the object

    def grtQ(self, steady_freqs, R_vector):
        '''This function takes as input both the steady-state frequencies and
        the R-vector in order to generate a Q-matrix according to the GTR
        phylogenetic model.'''
        Q = [[-1*(R_vector[0]*steady_freqs[1]+R_vector[1]*steady_freqs[2]+R_vector[2]*steady_freqs[3]),
              R_vector[0]*steady_freqs[1], R_vector[1]*steady_freqs[2],
              R_vector[2]*steady_freqs[3]], [R_vector[0]*steady_freqs[0],
             -1*(R_vector[0]*steady_freqs[0]+R_vector[3]*steady_freqs[2]+R_vector[4]*steady_freqs[3]),
             R_vector[3]*steady_freqs[2], R_vector[4]*steady_freqs[3]],
             [R_vector[1]*steady_freqs[0], R_vector[3]*steady_freqs[1],
             -1*(R_vector[1]*steady_freqs[0]+R_vector[3]*steady_freqs[1]+R_vector[5]*steady_freqs[3]),
             R_vector[5]*steady_freqs[3]], [R_vector[2]*steady_freqs[0],
             R_vector[4]*steady_freqs[1], R_vector[5]*steady_freqs[2],
             -1*(R_vector[2]*steady_freqs[0]+R_vector[4]*steady_freqs[1]+R_vector[5]*steady_freqs[2])]]
        return Q

            
    def simulate(self):
        '''This method simulates a Continuous-time Markov Chain with for the
        newly created Ctmc object. It takes as input the object and the
        attributes (such as branch-length, Q-matrix, state-space,
        and number of simulations) that characterize the chain.'''

        # Defining the variables that will be used in the function
        st_space = self.st_space
        Q = self.Q
        steady_freqs = self.steady_freqs
        v = self.v
        chain_hist = []  # creates and empty list to store the change history
        wait_time = self.wait_time
        marg_probs = self.marg_probs

        # Draw a starting state from the equilibrium frequencies.
        currStat = discSamp(st_space, steady_freqs)
        chain_hist.append(currStat)

        # Keep drawing waiting times and new states until the total time
        # exceeds the branch length.
        '''I just realized that this while statement is not working as it
        should. It keeps drawing a new state when the totalTime exceeds the
        condition, and I'm not sure why this is happening. I've tried using it
        outside the function (console) too and it is still not working:
            teste = Ctmc(v=1.0)

            teste.v
            Out[302]: 1.0

            teste.Q
            Out[303]:
        [[-1.0, 0.3333333333333333, 0.3333333333333333, 0.3333333333333333],
         [0.3333333333333333, -1.0, 0.3333333333333333, 0.3333333333333333],
         [0.3333333333333333, 0.3333333333333333, -1.0, 0.3333333333333333],
         [0.3333333333333333, 0.3333333333333333, 0.3333333333333333, -1.0]]

            teste.chain_hist
            Out[304]: ['G', 'T']

            teste.wait_time
            Out[305]: [1.1367266685758093]'''
        while sum(wait_time) < v:
            i = st_space.index(currStat)

            # Draw a waiting time from the appropriate exponential
            # distribution and appends it to the waiting times list created
            newTime = -1 * random.expovariate(Q[i][i])
            wait_time.append(newTime)

            # Creates two temporary lists to hold the values of the
            # marginal probabilities and the new state space after the
            # drawing of the last state space.
            marg_probs, new_states = [], []
            marg_probs.extend(Q[i])
            marg_probs.remove(marg_probs[i])
            new_states.extend(st_space)
            new_states.remove(new_states[i])

            # Draw a new state from the marginal probabilities associated with
            # the current state and appends it to the chain history list
            if sum(wait_time) <= v:
                currStat = discSamp(new_states, marg_probs)
                chain_hist.append(currStat)
            else:
                return None
        return wait_time, chain_hist
def estBrl(self,currBrl,diff,thresh):
    
    # Calculate the starting likelihood for currBrl. Multiply likelihoods from
    # different sites.
    
    # Calculate the likelihood for upBrl = currBrl+diff
    
    # Calculate the likelihood for downBrl = currBrl-diff. Check to make sure
    # this doesn't go below 0.
    
    while ((diff > thresh) & (currBrl < 20)):
    # NOTE: The ML branch-length estimate can sometimes be infinity. To avoid
    # the function trying to reach infinity, you should add a cutoff value for
    # the maximum possible branch-length. Something like 20 should be plenty 
    # large.
  
       # if #upBrl likelihood > currBrl likelihood :
            currBrl = upBrl
       # elif #downBrl likelihood > currBrl likelihood :
            currBrl = downBrl
       # else:
            diff *= 0.5
            
        # Recalculate likelihoods for new currBrl, upBrl, and downBrl
    
    return currBrl
    

"""
The ctmc class and methods are defined above. They are used and tested below.
"""    

# Simulate one site. Estimate branch length.



# Simulate several hundred sites. Estimate branch length.



# Run the above simulations repeatedly and examine variation in the estimated branch lengths.

c1 = Ctmc()
c2 = Ctmc(R_vector=[.34, .65, .44, .78, .49, .80])
